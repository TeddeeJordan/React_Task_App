import { createOvermind, createOvermindMock } from './';
import { statemachine } from './statemachine';
describe('Statemachine', () => {
    test('should set initial state', () => {
        const state = statemachine({
            TEST: () => { }
        }).create({
            current: 'FOO'
        });
        const config = {
            state,
        };
        const overmind = createOvermindMock(config);
        expect(overmind.state.current).toBe('FOO');
    });
    test('should set base state', () => {
        const state = statemachine({
            TEST: () => { }
        }).create({
            current: 'FOO',
        }, {
            foo: 'bar'
        });
        const config = {
            state,
        };
        const overmind = createOvermindMock(config);
        expect(overmind.state.current).toBe('FOO');
        expect(overmind.state.foo).toBe('bar');
    });
    test('should transition state', () => {
        const state = statemachine({
            TOGGLE: (state) => ({ current: state.current === 'FOO' ? 'BAR' : 'FOO' })
        }).create({
            current: 'FOO'
        });
        const transition = ({ state }) => {
            state.send('TOGGLE');
        };
        const config = {
            state,
            actions: {
                transition
            }
        };
        const overmind = createOvermindMock(config);
        overmind.actions.transition();
        expect(overmind.state.current).toBe('BAR');
    });
    test('should remove state when transitioning', () => {
        var _a;
        const state = statemachine({
            TOGGLE: () => ({ current: 'BAR' })
        }).create({
            current: 'FOO',
            foo: 'bar'
        });
        const transition = ({ state }) => {
            state.send('TOGGLE');
        };
        const config = {
            state,
            actions: {
                transition
            }
        };
        const overmind = createOvermindMock(config);
        expect(overmind.state.current).toBe('FOO');
        expect((_a = overmind.state.matches('FOO')) === null || _a === void 0 ? void 0 : _a.foo).toBe('bar');
        overmind.actions.transition();
        expect(overmind.state.current).toBe('BAR');
        expect(overmind.state.foo).toBe(undefined);
    });
    test('should block mutations in strict mode', () => {
        const state = statemachine({
            TOGGLE: (state) => {
                if (state.current === 'FOO') {
                    return { current: 'BAR' };
                }
                return { current: 'FOO', foo: 'bar' };
            }
        }).create({
            current: 'FOO',
            foo: 'bar'
        });
        const transition = ({ state }) => {
            const fooState = state.matches('FOO');
            if (fooState) {
                fooState.foo = 'bar2';
            }
        };
        const config = {
            state,
            actions: {
                transition
            }
        };
        const overmind = createOvermind(config, { devtools: false, strict: true, devEnv: 'test' });
        expect(() => overmind.actions.transition()).toThrow();
    });
    test('should ignore transition when no state returned', () => {
        const state = statemachine({
            TOGGLE: () => { }
        }).create({
            current: 'FOO'
        });
        const transition = ({ state }) => {
            state.send('TOGGLE');
        };
        const config = {
            state,
            actions: {
                transition
            }
        };
        const overmind = createOvermindMock(config);
        overmind.actions.transition();
        expect(overmind.state.current).toBe('FOO');
    });
    test('should flush changes to transitions', () => {
        expect.assertions(1);
        const state = statemachine({
            TOGGLE: () => ({ current: 'BAR' })
        }).create({
            current: 'FOO'
        });
        const transition = ({ state }) => {
            state.send('TOGGLE');
        };
        const config = {
            state,
            actions: {
                transition
            }
        };
        const overmind = createOvermind(config);
        overmind.reaction((state) => state.current, (value) => {
            expect(value).toEqual('BAR');
        });
        overmind.actions.transition();
    });
    test('should make copy of statemachine during tests', () => {
        const state = statemachine({
            TEST: () => { }
        }).create({
            current: 'FOO',
            obj: {
                foo: 'bar'
            }
        });
        const config = {
            state,
            actions: {
                changeFoo({ state }) {
                    state.obj.foo = 'bar2';
                }
            }
        };
        const overmind = createOvermindMock(config);
        // @ts-ignore
        overmind.actions.changeFoo();
        expect(overmind.state.obj.foo).toBe('bar2');
        const overmind2 = createOvermindMock(config);
        expect(overmind2.state.obj.foo).toBe('bar');
    });
});
//# sourceMappingURL=statemachine.test.js.map