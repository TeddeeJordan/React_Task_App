{"version":3,"file":"operators.test.js","sourceRoot":"","sources":["../src/operators.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Overmind,\n  pipe,\n  map,\n  forEach,\n  filter,\n  fork,\n  when,\n  IOperator,\n  wait,\n  debounce,\n  mutate,\n  parallel,\n  IConfig,\n  IAction,\n  catchError,\n  tryCatch,\n  throttle,\n  waitUntil,\n} from './'\n\ndescribe('OPERATORS', () => {\n  test('map', () => {\n    expect.assertions(1)\n    const test: Operator<string> = pipe(\n      map((_, value) => value.toUpperCase()),\n      mutate(({ state }, value) => (state.foo = value))\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('FOO')\n    })\n  })\n\n  test('map (async)', () => {\n    expect.assertions(1)\n    const test: Operator<string> = pipe(\n      map((_, value) => Promise.resolve(value.toUpperCase())),\n      mutate(({ state }, value) => (state.foo = value))\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('FOO')\n    })\n  })\n\n  test('forEach', () => {\n    expect.assertions(1)\n    let runCount = 0\n    const operator: any = (_, val, next) => {\n      runCount++\n      next(null, val)\n    }\n    const test: Operator<string[]> = pipe(forEach(operator))\n\n    const config = {\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    return overmind.actions.test(['foo']).then(() => {\n      expect(runCount).toEqual(1)\n    })\n  })\n\n  test('parallel', () => {\n    expect.assertions(1)\n    let runCount = 0\n    const operator: any = (_, value, next) => {\n      runCount++\n      next(null, value)\n    }\n    const test: Operator<string> = pipe(parallel(operator, operator))\n\n    const config = {\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(runCount).toEqual(2)\n    })\n  })\n\n  test('filter - truthy', () => {\n    expect.assertions(1)\n    const test: Operator<string> = pipe(\n      filter((_, value) => value === 'foo'),\n      map((_, value) => value.toUpperCase()),\n      mutate(({ state }, value) => (state.foo = value))\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('FOO')\n    })\n  })\n\n  test('filter - falsy', () => {\n    const test: Operator<string> = pipe(\n      filter((_, value) => value === 'bar'),\n      map((_, value) => value.toUpperCase()),\n      mutate(({ state }, value) => (state.foo = value))\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('bar')\n    })\n  })\n\n  test('fork', () => {\n    expect.assertions(1)\n    enum Key {\n      Foo = 'foo',\n    }\n    const test: Operator<string> = pipe(\n      fork(() => Key.Foo, {\n        [Key.Foo]: pipe(\n          map((_, value) => {\n            return value.toUpperCase()\n          }),\n          mutate(({ state }, value) => (state.foo = value))\n        ),\n      })\n    )\n\n    const config = {\n      state: {\n        foo: 'bar',\n      },\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('FOO')\n    })\n  })\n\n  test('when', () => {\n    expect.assertions(1)\n    const test: Operator<string, string | number> = pipe(\n      when(() => true, {\n        true: pipe(\n          map((_, value) => value.toUpperCase()),\n          mutate(({ state }, value) => (state.foo = value))\n        ),\n        false: pipe(\n          map((_, value) => Number(value)),\n          mutate(({ state }, value) => (state.number = value))\n        ),\n      })\n    )\n\n    const state = {\n      foo: 'bar',\n      number: 0,\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    return overmind.actions.test('foo').then(() => {\n      expect(overmind.state.foo).toBe('FOO')\n    })\n  })\n\n  test('wait', () => {\n    expect.assertions(1)\n    const runTime = Date.now()\n    const test: Operator = wait(500)\n\n    const config = {\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    return overmind.actions.test().then(() => {\n      expect(Date.now() - runTime).toBeGreaterThanOrEqual(500)\n    })\n  })\n\n  test('debounce', () => {\n    expect.assertions(1)\n    const test: Operator = pipe(\n      debounce(100),\n      mutate(({ state }) => state.runCount++)\n    )\n    const state = {\n      runCount: 0,\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(\n      () => {\n        expect(overmind.state.runCount).toBe(1)\n      }\n    )\n  })\n  test('throttle', () => {\n    expect.assertions(1)\n    const test: Operator = pipe(\n      throttle(0),\n      mutate(({ state }) => state.runCount++)\n    )\n    const state = {\n      runCount: 0,\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(\n      () => {\n        expect(overmind.state.runCount).toBe(1)\n      }\n    )\n  })\n\n  test('catchError', () => {\n    expect.assertions(3)\n    const test: Operator<string> = pipe(\n      mutate(() => {\n        throw new Error('wut?!?')\n      }),\n      mutate(({ state }) => {\n        state.runCount++\n      }),\n      catchError(({ state }, error) => {\n        state.error = error.message\n\n        return 'hm'\n      }),\n      mutate(({ state }, value) => {\n        state.foo = value\n      })\n    )\n    const state = {\n      runCount: 0,\n      foo: 'bar',\n      error: '',\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('baz').then(() => {\n      expect(overmind.state.runCount).toBe(0)\n      expect(overmind.state.error).toBe('wut?!?')\n      expect(overmind.state.foo).toBe('hm')\n    })\n  })\n  test('tryCatch - resolves', () => {\n    expect.assertions(1)\n    const test: Operator<string> = tryCatch({\n      try: mutate(({ state }, value) => {\n        state.foo = value\n      }),\n      catch: mutate(() => {}),\n    })\n    const state = {\n      foo: 'bar',\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('baz').then(() => {\n      expect(overmind.state.foo).toBe('baz')\n    })\n  })\n  test('tryCatch - fails', () => {\n    expect.assertions(1)\n    const test: Operator<string> = pipe(\n      tryCatch({\n        try: mutate(() => {\n          throw new Error('ehm')\n        }),\n        catch: mutate(({ state }, value) => {\n          state.foo = value.message\n        }),\n      })\n    )\n    const state = {\n      foo: 'bar',\n    }\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('baz').then(() => {\n      expect(overmind.state.foo).toBe('ehm')\n    })\n  })\n  test('waitUntil', () => {\n    expect.assertions(1)\n    const increaseCount: Operator = pipe(\n      mutate(({ state }) => state.runCount++)\n    )\n    const test: Operator = pipe(\n      waitUntil((state) => state.runCount === 1),\n      mutate(({ state }) => (state.hasRun = true))\n    )\n    const state = {\n      runCount: 0,\n      hasRun: false,\n    }\n    const config = {\n      state,\n      actions: {\n        increaseCount,\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    setTimeout(() => {\n      overmind.actions.increaseCount()\n    }, 0)\n\n    return overmind.actions.test().then(() => {\n      expect(overmind.state.runCount).toBe(1)\n    })\n  })\n})\n"]}