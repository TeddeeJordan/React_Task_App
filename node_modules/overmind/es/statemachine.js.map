{"version":3,"file":"statemachine.js","sourceRoot":"","sources":["../src/statemachine.ts"],"names":[],"mappings":"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","sourcesContent":["import { PATH, PROXY_TREE, VALUE } from 'proxy-state-tree'\n\nimport { deepCopy } from './utils'\nimport { IState } from '.'\n\ntype TState = {\n  current: string\n} & TBaseState\n\ntype TBaseState = {\n  [key: string]: IState | Statemachine<any, any, any>\n}\n\ntype TEvents = {\n  type: string\n  data?: any\n}\n\n\nexport type StatemachineTransitions<States extends TState, Events extends TEvents, BaseState extends TBaseState> = {\n  [Type in Events[\"type\"]]: [BaseState] extends [never] ?\n    ((state: States, payload: Events extends { type: Type } ? Events[\"data\"] : never) =>  States | void) :\n    ((state: States & BaseState, payload: Events extends { type: Type } ? Events[\"data\"] : never) =>  States | void)\n}\n\nexport interface MachineMethods<States extends TState, Events extends TEvents, BaseState extends TBaseState> {\n  matches<T extends States[\"current\"]>(\n    current: T,\n  ): Statemachine<States extends { current: T} ? States : never, Events, BaseState> | undefined\n  send<T extends Events[\"type\"]>(\n    ...args: Events extends { type: T, data: any } ? [T, Events[\"data\"]] : [T]\n  ): Statemachine<States, Events, BaseState>\n}\n\nexport type Statemachine<States extends TState, Events extends TEvents, BaseState extends TBaseState = never> = [BaseState] extends [never] ? States & MachineMethods<States, Events, BaseState> : States & BaseState & MachineMethods<States, Events, BaseState>\n\nconst INITIAL_STATE = Symbol('INITIAL_STATE')\nconst TRANSITIONS = Symbol('TRANSITIONS')\nconst STATE = Symbol('STATE')\nconst IS_DISPOSED = Symbol('IS_DISPOSED')\nconst CURRENT_KEYS = Symbol('CURRENT_KEYS')\nconst BASE_STATE = Symbol('BASE_STATE')\n\nexport class StateMachine<State extends TState, Events extends TEvents, BaseState extends TBaseState>  {\n  current: State[\"current\"]\n  private [INITIAL_STATE]: State[\"current\"]\n  private [TRANSITIONS]: StatemachineTransitions<State, Events, BaseState>\n  private [STATE]: any\n  private [BASE_STATE]: BaseState\n  private [IS_DISPOSED] = false\n  private clone() {\n    return new StateMachine(this[TRANSITIONS], deepCopy(this[STATE]), deepCopy(this[BASE_STATE]))\n  }\n  private dispose() {\n    Object.keys(this[VALUE]).forEach((key) => {\n      if (this[VALUE][key] instanceof StateMachine) {\n        this[key].dispose()\n      }\n    })\n    this[VALUE][IS_DISPOSED] = true\n  }\n  constructor(transitions: StatemachineTransitions<State, Events, BaseState>, state: State, baseState: BaseState) {\n    this[STATE] = state\n    this[BASE_STATE] = baseState\n    this[INITIAL_STATE] = state.current\n    this[BASE_STATE] = baseState\n    this[TRANSITIONS] = transitions\n    this[CURRENT_KEYS] = Object.keys(state)\n    Object.assign(this, state, baseState)\n  }\n  send(type, data) {\n    if (this[VALUE][IS_DISPOSED]) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`Overmind - The statemachine at \"${this[PATH]}\" has been disposed, but you tried to transition on it`)\n      }\n      return this\n    }\n\n    const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])\n    const transition = this[VALUE][TRANSITIONS][type]\n\n    tree.enableMutations()\n    const result = transition(this, data)\n\n    if (result) {\n      this[VALUE][CURRENT_KEYS].forEach((key) => {\n        if (key !== 'current') {\n          delete this[key]\n        }\n      })\n      this[VALUE][CURRENT_KEYS] = Object.keys(result)\n      Object.assign(this, result)\n    }\n\n    tree.blockMutations()\n\n    return this\n  }\n  matches(state: any) {\n    if (this.current === state) {\n      return this\n    }\n  }\n}\n\nexport type StatemachineFactory<States extends TState, Events extends TEvents, BaseState extends TBaseState> = [BaseState] extends [never] ? {\n  create(state: States): Statemachine<States, Events, {}> \n} : {\n  create(state: States, baseState: BaseState): Statemachine<States, Events, BaseState> \n}\n\nexport function statemachine<States extends TState, Events extends TEvents, BaseState extends TBaseState = never>(transitions: StatemachineTransitions<States, Events, BaseState>): StatemachineFactory<States, Events, BaseState> {\n   return {\n     create(state, baseState) {\n      return new StateMachine(transitions, state as any, baseState as any)\n     }\n   } as any\n}\n"]}