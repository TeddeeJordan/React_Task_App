var _a;
import { PATH, PROXY_TREE, VALUE } from 'proxy-state-tree';
import { deepCopy } from './utils';
const INITIAL_STATE = Symbol('INITIAL_STATE');
const TRANSITIONS = Symbol('TRANSITIONS');
const STATE = Symbol('STATE');
const IS_DISPOSED = Symbol('IS_DISPOSED');
const CURRENT_KEYS = Symbol('CURRENT_KEYS');
const BASE_STATE = Symbol('BASE_STATE');
export class StateMachine {
    constructor(transitions, state, baseState) {
        this[_a] = false;
        this[STATE] = state;
        this[BASE_STATE] = baseState;
        this[INITIAL_STATE] = state.current;
        this[BASE_STATE] = baseState;
        this[TRANSITIONS] = transitions;
        this[CURRENT_KEYS] = Object.keys(state);
        Object.assign(this, state, baseState);
    }
    clone() {
        return new StateMachine(this[TRANSITIONS], deepCopy(this[STATE]), deepCopy(this[BASE_STATE]));
    }
    dispose() {
        Object.keys(this[VALUE]).forEach((key) => {
            if (this[VALUE][key] instanceof StateMachine) {
                this[key].dispose();
            }
        });
        this[VALUE][IS_DISPOSED] = true;
    }
    send(type, data) {
        if (this[VALUE][IS_DISPOSED]) {
            if (process.env.NODE_ENV === 'development') {
                console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to transition on it`);
            }
            return this;
        }
        const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE]);
        const transition = this[VALUE][TRANSITIONS][type];
        tree.enableMutations();
        const result = transition(this, data);
        if (result) {
            this[VALUE][CURRENT_KEYS].forEach((key) => {
                if (key !== 'current') {
                    delete this[key];
                }
            });
            this[VALUE][CURRENT_KEYS] = Object.keys(result);
            Object.assign(this, result);
        }
        tree.blockMutations();
        return this;
    }
    matches(state) {
        if (this.current === state) {
            return this;
        }
    }
}
_a = IS_DISPOSED;
export function statemachine(transitions) {
    return {
        create(state, baseState) {
            return new StateMachine(transitions, state, baseState);
        }
    };
}
//# sourceMappingURL=statemachine.js.map