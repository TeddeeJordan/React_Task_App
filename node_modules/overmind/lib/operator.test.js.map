{"version":3,"file":"operator.test.js","sourceRoot":"","sources":["../src/operator.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { createOperator, createMutationOperator } from './operator'\nimport { Overmind, IConfig, IOperator, pipe, map, mutate, IAction } from './'\nimport { IS_PROXY, PATH } from 'proxy-state-tree'\n\ndescribe('OPERATOR', () => {\n  test('should be able to create an operator', () => {\n    expect.assertions(1)\n    function toUpperCase(): Operator<string> {\n      return createOperator('toUpperCase', '', (err, _, value, next) => {\n        if (err) next(err, value)\n        else next(null, value.toUpperCase())\n      })\n    }\n\n    const test: Operator = pipe(\n      map(({ state }) => state.foo),\n      toUpperCase(),\n      mutate(({ state }, val) => {\n        state.foo = val\n      })\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test().then(() => {\n      expect(overmind.state.foo).toBe('BAR')\n    })\n  })\n  test('should be able to create an ERROR operator', () => {\n    let operatorsRun = 0\n\n    expect.assertions(2)\n    function catchError<Input>(\n      operation: (error: Error) => void\n    ): Operator<Input> {\n      return createOperator(\n        'catchError',\n        operation.name,\n        (err, _, value, next) => {\n          if (err) next(null, operation(err))\n          else next(null, value)\n        }\n      )\n    }\n\n    const test: Operator = pipe(\n      mutate(() => {\n        throw new Error('wut')\n      }),\n      mutate(({ state }, val) => {\n        operatorsRun++\n      }),\n      catchError((err) => {\n        expect(err.message).toBe('wut')\n      })\n    )\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test().then(() => {\n      expect(operatorsRun).toBe(0)\n    })\n  })\n  test('should be able to create an operator managing paths', () => {\n    expect.assertions(1)\n    function whenBananaOrApple(paths: {\n      banana: Operator<string>\n      apple: Operator<string>\n    }): Operator<string> {\n      return createOperator('whenBananaOrApple', '', (err, _, value, next) => {\n        if (err) next(err, value)\n        else\n          next(null, value, {\n            path: {\n              name: value,\n              operator: paths[value],\n            },\n          })\n      })\n    }\n\n    const test: Operator<string> = whenBananaOrApple({\n      banana: mutate(({ state }) => {\n        state.foo = 'banana'\n      }),\n      apple: mutate(({ state }) => {\n        state.foo = 'apple'\n      }),\n    })\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test('banana').then(() => {\n      expect(overmind.state.foo).toBe('banana')\n    })\n  })\n  test('should be able to create an operator that can mutate', () => {\n    expect.assertions(1)\n    function changeState<Input>(\n      operation: (state: Config['state']) => void\n    ): Operator<Input> {\n      return createMutationOperator<Config>(\n        'changeState',\n        operation.name,\n        (err, context, value, next) => {\n          if (err) next(err, value)\n          else {\n            operation(context.state)\n            next(null, value)\n          }\n        }\n      )\n    }\n\n    const test: Operator = changeState((state) => {\n      state.foo = 'hihihi'\n    })\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    return overmind.actions.test().then(() => {\n      expect(overmind.state.foo).toBe('hihihi')\n    })\n  })\n  test('should be able to create an operator that can track mutations', (done) => {\n    function waitForMutation(\n      operation: (state: Config['state']) => void\n    ): Operator {\n      return createOperator<Config>(\n        'waitForMutation',\n        operation.name,\n        (err, context, value, next) => {\n          if (err) next(err, value)\n          else {\n            const tree = context.execution.getTrackStateTree()\n            tree.trackScope(\n              () => {\n                operation(tree.state)\n              },\n              () => {\n                tree.dispose()\n                next(null, value)\n              }\n            )\n          }\n        }\n      )\n    }\n\n    const waitForFoo: Operator = waitForMutation((state) => {\n      state.foo\n    })\n\n    const test: Operator = pipe(waitForFoo)\n\n    const mutateFoo: Action = ({ state }) => {\n      state.foo = 'hihihi'\n    }\n\n    const state = {\n      foo: 'bar',\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n        mutateFoo,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void, Output = void | Promise<void>>\n      extends IAction<Config, Input, Output> {}\n\n    overmind.actions.test().then(done)\n\n    // Trigger mutation with an action.\n    overmind.actions.mutateFoo()\n  })\n  test('should be able to create an operator that evaluates mutations', (done) => {\n    function waitUntilTrue(\n      operation: (state: Config['state']) => boolean\n    ): Operator {\n      return createOperator<Config>(\n        'waitUntilTrue',\n        operation.name,\n        (err, context, value, next) => {\n          if (err) next(err, value)\n          else {\n            const tree = context.execution.getTrackStateTree()\n            const test = () => {\n              if (operation(tree.state)) {\n                tree.dispose()\n                next(null, value)\n              }\n            }\n            tree.trackScope(test, test)\n          }\n        }\n      )\n    }\n\n    const waitForFoo: Operator = waitUntilTrue(\n      (state) => state.foo.bar === 'hihihi'\n    )\n\n    const test: Operator = pipe(waitForFoo)\n\n    const mutateBar: Action = ({ state }) => {\n      state.foo.bar = 'hihihi'\n    }\n\n    const state = {\n      foo: {\n        bar: 'baz',\n      },\n    }\n\n    const config = {\n      state,\n      actions: {\n        test,\n        mutateBar,\n      },\n    }\n    const overmind = new Overmind(config)\n\n    type Config = IConfig<typeof config>\n\n    interface Operator<Input = void, Output = Input>\n      extends IOperator<Config, Input, Output> {}\n\n    interface Action<Input = void> extends IAction<Config, Input> {}\n\n    overmind.actions.test().then(done)\n\n    // Trigger mutation with an action.\n    overmind.actions.mutateBar()\n  })\n})\n"]}