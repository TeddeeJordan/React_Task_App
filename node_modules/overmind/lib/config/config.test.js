"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const __1 = require("../");
const _1 = require("./");
describe('Config', () => {
    test('should merge configs', () => {
        const configA = {
            state: {
                foo: 'bar',
            },
        };
        const configB = {
            state: {
                bar: 'baz',
            },
        };
        const merged = _1.merge(configA, configB);
        expect(merged.state.foo).toEqual('bar');
        expect(merged.state.bar).toEqual('baz');
    });
    test('should namespace', () => {
        const configA = {
            state: {
                foo: 'bar',
            },
        };
        const configB = {
            state: {
                bar: 'baz',
            },
        };
        const merged = _1.namespaced({ configA, configB });
        expect(merged.state.configA.foo).toEqual('bar');
        expect(merged.state.configB.bar).toEqual('baz');
    });
    test('should create lazy config', () => {
        const configA = () => Promise.resolve({
            state: {
                foo: 'bar',
            },
            actions: {
                returnStateFromB({ state }) {
                    return state.configB.bar;
                },
            },
        });
        const configB = () => Promise.resolve({
            state: {
                bar: 'baz',
            },
        });
        const merged = _1.merge({
            actions: {
                loadConfigB: ({ effects }) => {
                    return effects.lazy.loadConfig('configB');
                },
            },
        }, _1.lazy({ configA, configB }));
        const app = new __1.Overmind(merged);
        return Promise.all([
            app.actions.lazy.loadConfig('configA'),
            app.actions.loadConfigB(),
        ]).then(() => {
            // @ts-ignore
            expect(app.state.configA.foo).toEqual('bar');
            // @ts-ignore
            expect(app.state.configB.bar).toEqual('baz');
            // @ts-ignore
            expect(app.actions.configA.returnStateFromB()).toEqual('baz');
        });
    });
    test('should merge normal and namespaced', () => {
        const configA = {
            state: {
                foo: 'bar',
            },
        };
        const configB = {
            state: {
                bar: 'baz',
            },
        };
        const merged = _1.merge(configA, _1.namespaced({ configB }));
        expect(merged.state.foo).toEqual('bar');
        expect(merged.state.configB.bar).toEqual('baz');
    });
    test('should keep context when lazy loading namespaces', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                changeFoo(context) {
                    context.state.config.foo = 'bar2';
                }
            }
        };
        const overmind = __1.createOvermindMock(_1.lazy({
            config: () => Promise.resolve(config)
        }));
        yield overmind.onInitialize();
        yield overmind.actions.lazy.loadConfig('config');
        // @ts-ignore
        overmind.actions.config.changeFoo();
        expect(overmind.state.config.foo).toEqual('bar2');
    }));
});
//# sourceMappingURL=config.test.js.map