import { IState } from '.';
declare type TState = {
    current: string;
} & TBaseState;
declare type TBaseState = {
    [key: string]: IState | Statemachine<any, any, any>;
};
declare type TEvents = {
    type: string;
    data?: any;
};
export declare type StatemachineTransitions<States extends TState, Events extends TEvents, BaseState extends TBaseState> = {
    [Type in Events["type"]]: [BaseState] extends [never] ? ((state: States, payload: Events extends {
        type: Type;
    } ? Events["data"] : never) => States | void) : ((state: States & BaseState, payload: Events extends {
        type: Type;
    } ? Events["data"] : never) => States | void);
};
export interface MachineMethods<States extends TState, Events extends TEvents, BaseState extends TBaseState> {
    matches<T extends States["current"]>(current: T): Statemachine<States extends {
        current: T;
    } ? States : never, Events, BaseState> | undefined;
    send<T extends Events["type"]>(...args: Events extends {
        type: T;
        data: any;
    } ? [T, Events["data"]] : [T]): Statemachine<States, Events, BaseState>;
}
export declare type Statemachine<States extends TState, Events extends TEvents, BaseState extends TBaseState = never> = [BaseState] extends [never] ? States & MachineMethods<States, Events, BaseState> : States & BaseState & MachineMethods<States, Events, BaseState>;
declare const INITIAL_STATE: unique symbol;
declare const TRANSITIONS: unique symbol;
declare const STATE: unique symbol;
declare const IS_DISPOSED: unique symbol;
declare const BASE_STATE: unique symbol;
export declare class StateMachine<State extends TState, Events extends TEvents, BaseState extends TBaseState> {
    current: State["current"];
    private [INITIAL_STATE];
    private [TRANSITIONS];
    private [STATE];
    private [BASE_STATE];
    private [IS_DISPOSED];
    private clone;
    private dispose;
    constructor(transitions: StatemachineTransitions<State, Events, BaseState>, state: State, baseState: BaseState);
    send(type: any, data: any): this;
    matches(state: any): this | undefined;
}
export declare type StatemachineFactory<States extends TState, Events extends TEvents, BaseState extends TBaseState> = [BaseState] extends [never] ? {
    create(state: States): Statemachine<States, Events, {}>;
} : {
    create(state: States, baseState: BaseState): Statemachine<States, Events, BaseState>;
};
export declare function statemachine<States extends TState, Events extends TEvents, BaseState extends TBaseState = never>(transitions: StatemachineTransitions<States, Events, BaseState>): StatemachineFactory<States, Events, BaseState>;
export {};
