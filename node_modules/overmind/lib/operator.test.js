"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const operator_1 = require("./operator");
const _1 = require("./");
describe('OPERATOR', () => {
    test('should be able to create an operator', () => {
        expect.assertions(1);
        function toUpperCase() {
            return operator_1.createOperator('toUpperCase', '', (err, _, value, next) => {
                if (err)
                    next(err, value);
                else
                    next(null, value.toUpperCase());
            });
        }
        const test = _1.pipe(_1.map(({ state }) => state.foo), toUpperCase(), _1.mutate(({ state }, val) => {
            state.foo = val;
        }));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test().then(() => {
            expect(overmind.state.foo).toBe('BAR');
        });
    });
    test('should be able to create an ERROR operator', () => {
        let operatorsRun = 0;
        expect.assertions(2);
        function catchError(operation) {
            return operator_1.createOperator('catchError', operation.name, (err, _, value, next) => {
                if (err)
                    next(null, operation(err));
                else
                    next(null, value);
            });
        }
        const test = _1.pipe(_1.mutate(() => {
            throw new Error('wut');
        }), _1.mutate(({ state }, val) => {
            operatorsRun++;
        }), catchError((err) => {
            expect(err.message).toBe('wut');
        }));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test().then(() => {
            expect(operatorsRun).toBe(0);
        });
    });
    test('should be able to create an operator managing paths', () => {
        expect.assertions(1);
        function whenBananaOrApple(paths) {
            return operator_1.createOperator('whenBananaOrApple', '', (err, _, value, next) => {
                if (err)
                    next(err, value);
                else
                    next(null, value, {
                        path: {
                            name: value,
                            operator: paths[value],
                        },
                    });
            });
        }
        const test = whenBananaOrApple({
            banana: _1.mutate(({ state }) => {
                state.foo = 'banana';
            }),
            apple: _1.mutate(({ state }) => {
                state.foo = 'apple';
            }),
        });
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('banana').then(() => {
            expect(overmind.state.foo).toBe('banana');
        });
    });
    test('should be able to create an operator that can mutate', () => {
        expect.assertions(1);
        function changeState(operation) {
            return operator_1.createMutationOperator('changeState', operation.name, (err, context, value, next) => {
                if (err)
                    next(err, value);
                else {
                    operation(context.state);
                    next(null, value);
                }
            });
        }
        const test = changeState((state) => {
            state.foo = 'hihihi';
        });
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test().then(() => {
            expect(overmind.state.foo).toBe('hihihi');
        });
    });
    test('should be able to create an operator that can track mutations', (done) => {
        function waitForMutation(operation) {
            return operator_1.createOperator('waitForMutation', operation.name, (err, context, value, next) => {
                if (err)
                    next(err, value);
                else {
                    const tree = context.execution.getTrackStateTree();
                    tree.trackScope(() => {
                        operation(tree.state);
                    }, () => {
                        tree.dispose();
                        next(null, value);
                    });
                }
            });
        }
        const waitForFoo = waitForMutation((state) => {
            state.foo;
        });
        const test = _1.pipe(waitForFoo);
        const mutateFoo = ({ state }) => {
            state.foo = 'hihihi';
        };
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
                mutateFoo,
            },
        };
        const overmind = new _1.Overmind(config);
        overmind.actions.test().then(done);
        // Trigger mutation with an action.
        overmind.actions.mutateFoo();
    });
    test('should be able to create an operator that evaluates mutations', (done) => {
        function waitUntilTrue(operation) {
            return operator_1.createOperator('waitUntilTrue', operation.name, (err, context, value, next) => {
                if (err)
                    next(err, value);
                else {
                    const tree = context.execution.getTrackStateTree();
                    const test = () => {
                        if (operation(tree.state)) {
                            tree.dispose();
                            next(null, value);
                        }
                    };
                    tree.trackScope(test, test);
                }
            });
        }
        const waitForFoo = waitUntilTrue((state) => state.foo.bar === 'hihihi');
        const test = _1.pipe(waitForFoo);
        const mutateBar = ({ state }) => {
            state.foo.bar = 'hihihi';
        };
        const state = {
            foo: {
                bar: 'baz',
            },
        };
        const config = {
            state,
            actions: {
                test,
                mutateBar,
            },
        };
        const overmind = new _1.Overmind(config);
        overmind.actions.test().then(done);
        // Trigger mutation with an action.
        overmind.actions.mutateBar();
    });
});
//# sourceMappingURL=operator.test.js.map