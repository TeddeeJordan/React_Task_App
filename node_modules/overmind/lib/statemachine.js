"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.statemachine = exports.StateMachine = void 0;
const proxy_state_tree_1 = require("proxy-state-tree");
const utils_1 = require("./utils");
const INITIAL_STATE = Symbol('INITIAL_STATE');
const TRANSITIONS = Symbol('TRANSITIONS');
const STATE = Symbol('STATE');
const IS_DISPOSED = Symbol('IS_DISPOSED');
const CURRENT_KEYS = Symbol('CURRENT_KEYS');
const BASE_STATE = Symbol('BASE_STATE');
class StateMachine {
    constructor(transitions, state, baseState) {
        this[_a] = false;
        this[STATE] = state;
        this[BASE_STATE] = baseState;
        this[INITIAL_STATE] = state.current;
        this[BASE_STATE] = baseState;
        this[TRANSITIONS] = transitions;
        this[CURRENT_KEYS] = Object.keys(state);
        Object.assign(this, state, baseState);
    }
    clone() {
        return new StateMachine(this[TRANSITIONS], utils_1.deepCopy(this[STATE]), utils_1.deepCopy(this[BASE_STATE]));
    }
    dispose() {
        Object.keys(this[proxy_state_tree_1.VALUE]).forEach((key) => {
            if (this[proxy_state_tree_1.VALUE][key] instanceof StateMachine) {
                this[key].dispose();
            }
        });
        this[proxy_state_tree_1.VALUE][IS_DISPOSED] = true;
    }
    send(type, data) {
        if (this[proxy_state_tree_1.VALUE][IS_DISPOSED]) {
            if (process.env.NODE_ENV === 'development') {
                console.warn(`Overmind - The statemachine at "${this[proxy_state_tree_1.PATH]}" has been disposed, but you tried to transition on it`);
            }
            return this;
        }
        const tree = (this[proxy_state_tree_1.PROXY_TREE].master.mutationTree || this[proxy_state_tree_1.PROXY_TREE]);
        const transition = this[proxy_state_tree_1.VALUE][TRANSITIONS][type];
        tree.enableMutations();
        const result = transition(this, data);
        if (result) {
            this[proxy_state_tree_1.VALUE][CURRENT_KEYS].forEach((key) => {
                if (key !== 'current') {
                    delete this[key];
                }
            });
            this[proxy_state_tree_1.VALUE][CURRENT_KEYS] = Object.keys(result);
            Object.assign(this, result);
        }
        tree.blockMutations();
        return this;
    }
    matches(state) {
        if (this.current === state) {
            return this;
        }
    }
}
exports.StateMachine = StateMachine;
_a = IS_DISPOSED;
function statemachine(transitions) {
    return {
        create(state, baseState) {
            return new StateMachine(transitions, state, baseState);
        }
    };
}
exports.statemachine = statemachine;
//# sourceMappingURL=statemachine.js.map