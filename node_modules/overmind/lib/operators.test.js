"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
describe('OPERATORS', () => {
    test('map', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.map((_, value) => value.toUpperCase()), _1.mutate(({ state }, value) => (state.foo = value)));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('FOO');
        });
    });
    test('map (async)', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.map((_, value) => Promise.resolve(value.toUpperCase())), _1.mutate(({ state }, value) => (state.foo = value)));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('FOO');
        });
    });
    test('forEach', () => {
        expect.assertions(1);
        let runCount = 0;
        const operator = (_, val, next) => {
            runCount++;
            next(null, val);
        };
        const test = _1.pipe(_1.forEach(operator));
        const config = {
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test(['foo']).then(() => {
            expect(runCount).toEqual(1);
        });
    });
    test('parallel', () => {
        expect.assertions(1);
        let runCount = 0;
        const operator = (_, value, next) => {
            runCount++;
            next(null, value);
        };
        const test = _1.pipe(_1.parallel(operator, operator));
        const config = {
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(runCount).toEqual(2);
        });
    });
    test('filter - truthy', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.filter((_, value) => value === 'foo'), _1.map((_, value) => value.toUpperCase()), _1.mutate(({ state }, value) => (state.foo = value)));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('FOO');
        });
    });
    test('filter - falsy', () => {
        const test = _1.pipe(_1.filter((_, value) => value === 'bar'), _1.map((_, value) => value.toUpperCase()), _1.mutate(({ state }, value) => (state.foo = value)));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('bar');
        });
    });
    test('fork', () => {
        expect.assertions(1);
        let Key;
        (function (Key) {
            Key["Foo"] = "foo";
        })(Key || (Key = {}));
        const test = _1.pipe(_1.fork(() => Key.Foo, {
            [Key.Foo]: _1.pipe(_1.map((_, value) => {
                return value.toUpperCase();
            }), _1.mutate(({ state }, value) => (state.foo = value))),
        }));
        const config = {
            state: {
                foo: 'bar',
            },
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('FOO');
        });
    });
    test('when', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.when(() => true, {
            true: _1.pipe(_1.map((_, value) => value.toUpperCase()), _1.mutate(({ state }, value) => (state.foo = value))),
            false: _1.pipe(_1.map((_, value) => Number(value)), _1.mutate(({ state }, value) => (state.number = value))),
        }));
        const state = {
            foo: 'bar',
            number: 0,
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('foo').then(() => {
            expect(overmind.state.foo).toBe('FOO');
        });
    });
    test('wait', () => {
        expect.assertions(1);
        const runTime = Date.now();
        const test = _1.wait(500);
        const config = {
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test().then(() => {
            expect(Date.now() - runTime).toBeGreaterThanOrEqual(500);
        });
    });
    test('debounce', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.debounce(100), _1.mutate(({ state }) => state.runCount++));
        const state = {
            runCount: 0,
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(() => {
            expect(overmind.state.runCount).toBe(1);
        });
    });
    test('throttle', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.throttle(0), _1.mutate(({ state }) => state.runCount++));
        const state = {
            runCount: 0,
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(() => {
            expect(overmind.state.runCount).toBe(1);
        });
    });
    test('catchError', () => {
        expect.assertions(3);
        const test = _1.pipe(_1.mutate(() => {
            throw new Error('wut?!?');
        }), _1.mutate(({ state }) => {
            state.runCount++;
        }), _1.catchError(({ state }, error) => {
            state.error = error.message;
            return 'hm';
        }), _1.mutate(({ state }, value) => {
            state.foo = value;
        }));
        const state = {
            runCount: 0,
            foo: 'bar',
            error: '',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('baz').then(() => {
            expect(overmind.state.runCount).toBe(0);
            expect(overmind.state.error).toBe('wut?!?');
            expect(overmind.state.foo).toBe('hm');
        });
    });
    test('tryCatch - resolves', () => {
        expect.assertions(1);
        const test = _1.tryCatch({
            try: _1.mutate(({ state }, value) => {
                state.foo = value;
            }),
            catch: _1.mutate(() => { }),
        });
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('baz').then(() => {
            expect(overmind.state.foo).toBe('baz');
        });
    });
    test('tryCatch - fails', () => {
        expect.assertions(1);
        const test = _1.pipe(_1.tryCatch({
            try: _1.mutate(() => {
                throw new Error('ehm');
            }),
            catch: _1.mutate(({ state }, value) => {
                state.foo = value.message;
            }),
        }));
        const state = {
            foo: 'bar',
        };
        const config = {
            state,
            actions: {
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        return overmind.actions.test('baz').then(() => {
            expect(overmind.state.foo).toBe('ehm');
        });
    });
    test('waitUntil', () => {
        expect.assertions(1);
        const increaseCount = _1.pipe(_1.mutate(({ state }) => state.runCount++));
        const test = _1.pipe(_1.waitUntil((state) => state.runCount === 1), _1.mutate(({ state }) => (state.hasRun = true)));
        const state = {
            runCount: 0,
            hasRun: false,
        };
        const config = {
            state,
            actions: {
                increaseCount,
                test,
            },
        };
        const overmind = new _1.Overmind(config);
        setTimeout(() => {
            overmind.actions.increaseCount();
        }, 0);
        return overmind.actions.test().then(() => {
            expect(overmind.state.runCount).toBe(1);
        });
    });
});
//# sourceMappingURL=operators.test.js.map