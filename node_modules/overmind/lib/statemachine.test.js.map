{"version":3,"file":"statemachine.test.js","sourceRoot":"","sources":["../src/statemachine.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { IAction, createOvermind, createOvermindMock } from './'\nimport { statemachine } from './statemachine'\n\ndescribe('Statemachine', () => {\n  \n  test('should set initial state', () => {\n\n    type States = {\n      current: 'FOO'\n    } | {\n      current: 'BAR'\n    }\n\n    const state = statemachine<States, { type: 'TEST'}>({\n      TEST: () => {}\n    }).create({\n      current: 'FOO'\n    })\n\n    \n    const config = {\n      state,\n    } \n\n    const overmind = createOvermindMock(config)\n\n    expect(overmind.state.current).toBe('FOO')\n  })\n\n  test('should set base state', () => {\n\n    type States = {\n      current: 'FOO'\n    } | {\n      current: 'BAR'\n    }\n\n    type BaseState = {\n      foo: string\n    }\n\n    const state = statemachine<States, { type: 'TEST' }, BaseState>({\n      TEST: () => {}\n    }).create({\n      current: 'FOO',\n    }, {\n      foo: 'bar'\n    })\n\n    \n    const config = {\n      state,\n    } \n\n    const overmind = createOvermindMock(config)\n\n    expect(overmind.state.current).toBe('FOO')\n    expect(overmind.state.foo).toBe('bar')\n  })\n\n\n  test('should transition state', () => {\n    type States = {\n     current: 'FOO'\n    } | {\n      current: 'BAR'\n    }\n\n    type Events = {\n      type: 'TOGGLE',\n    }\n\n    const state = statemachine<States, Events>({\n      TOGGLE: (state) => ({ current: state.current === 'FOO' ? 'BAR' : 'FOO' })\n    }).create({\n      current: 'FOO'\n    })\n    const transition: Action = ({ state }) => {\n      state.send('TOGGLE')\n    }\n\n    const config = {\n      state,\n      actions: {\n        transition\n      }\n    } \n\n    interface Action extends IAction<typeof config, void, void> {}\n\n    const overmind = createOvermindMock(config)\n    \n\n    overmind.actions.transition()\n    expect(overmind.state.current).toBe('BAR')\n  })\n\n  test('should remove state when transitioning', () => {\n    type States = {\n     current: 'FOO'\n     foo: string\n    } | {\n      current: 'BAR'\n    }\n\n    type Events = {\n      type: 'TOGGLE',\n    }\n\n    const state = statemachine<States, Events>({\n      TOGGLE: () => ({ current: 'BAR' })\n    }).create({\n      current: 'FOO',\n      foo: 'bar'\n    })\n    const transition: Action = ({ state }) => {\n      state.send('TOGGLE')\n    }\n\n    const config = {\n      state,\n      actions: {\n        transition\n      }\n    } \n\n    interface Action extends IAction<typeof config, void, void> {}\n\n    const overmind = createOvermindMock(config)\n    \n\n    expect(overmind.state.current).toBe('FOO')\n    expect(overmind.state.matches('FOO')?.foo).toBe('bar')\n    overmind.actions.transition()\n    expect(overmind.state.current).toBe('BAR')\n    expect((overmind.state as any).foo).toBe(undefined)\n  })\n\n  test('should block mutations in strict mode', () => {\n    type States = {\n     current: 'FOO'\n     foo: string\n    } | {\n      current: 'BAR'\n    }\n\n    type Events = {\n      type: 'TOGGLE',\n    }\n\n    const state = statemachine<States, Events>({\n      TOGGLE: (state) => {\n        if (state.current === 'FOO') {\n          return { current: 'BAR' }\n        }\n\n        return { current: 'FOO', foo: 'bar'}\n      }\n    }).create({\n      current: 'FOO',\n      foo: 'bar'\n    })\n    const transition: Action = ({ state }) => {\n      const fooState = state.matches('FOO')\n      if (fooState) {\n        fooState.foo = 'bar2'\n      }\n    }\n\n    const config = {\n      state,\n      actions: {\n        transition\n      }\n    } \n\n    interface Action extends IAction<typeof config, void, void> {}\n\n    const overmind = createOvermind(config, {devtools: false, strict: true, devEnv: 'test'})\n    \n    expect(() => overmind.actions.transition()).toThrow()\n  })\n\n  \n  test('should ignore transition when no state returned', () => {\n\n    type States = {\n      current: 'FOO'\n    } | {\n      current: 'BAR'\n    }\n\n    type Events = {\n      type: 'TOGGLE',\n    }\n\n    const state = statemachine<States, Events>({\n      TOGGLE: () => {}\n    }).create({\n      current: 'FOO'\n    })\n    const transition: Action = ({ state }) => {\n      state.send('TOGGLE')\n    }\n\n    const config = {\n      state,\n      actions: {\n        transition\n      }\n    } \n\n    interface Action extends IAction<typeof config, void, void> {}\n\n    const overmind = createOvermindMock(config)\n    overmind.actions.transition()\n    expect(overmind.state.current).toBe('FOO')\n  })\n\n\n\n  test('should flush changes to transitions', () => {\n    expect.assertions(1)\n\n    type States = {\n      current: 'FOO'\n    } | {\n      current: 'BAR'\n    }\n\n    type Events = {\n      type: 'TOGGLE',\n    }\n\n    const state = statemachine<States, Events>({\n      TOGGLE: () => ({ current: 'BAR' })\n    }).create({\n      current: 'FOO'\n    })\n    \n    const transition: Action = ({ state }) => {\n      state.send('TOGGLE')\n    }\n\n    const config = {\n      state,\n      actions: {\n        transition\n      }\n    } \n\n    interface Action extends IAction<typeof config, void, void> {}\n\n    const overmind = createOvermind(config)\n    overmind.reaction((state) => state.current, (value) => {\n      expect(value).toEqual('BAR')\n    })\n    overmind.actions.transition()\n  })\n\n  test('should make copy of statemachine during tests', () => {\n    type States = {\n      current: 'FOO'\n      obj: {\n        foo: string\n      }\n    } | {\n      current: 'BAR',\n      obj: {\n        foo: string\n      }\n    }\n\n    const state = statemachine<States, { type: 'TEST'}>({\n      TEST: () => {}\n    }).create({\n      current: 'FOO',\n      obj: {\n        foo: 'bar'\n      }\n    })\n    \n    const config = {\n      state,\n      actions: {\n        changeFoo({ state }) {\n          state.obj.foo = 'bar2'\n        }\n      }\n    } \n\n    const overmind = createOvermindMock(config)\n\n    // @ts-ignore\n    overmind.actions.changeFoo()\n\n    expect(overmind.state.obj.foo).toBe('bar2')\n\n\n    const overmind2 = createOvermindMock(config)\n\n    expect(overmind2.state.obj.foo).toBe('bar')\n  })\n})\n"]}